<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Abyss - FPS Roguelike</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }
        
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #hud-top {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            color: #0ff;
            font-size: 24px;
            text-shadow: 0 0 10px #0ff;
            background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
        }

        #hud-bottom {
            padding: 20px;
            color: #f0f;
            font-size: 20px;
            text-shadow: 0 0 10px #f0f;
            text-align: center;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        .cross-line {
            background: rgba(255, 255, 255, 0.8);
            position: absolute;
            box-shadow: 0 0 5px #fff;
        }
        
        .cross-h { width: 100%; height: 2px; top: 9px; }
        .cross-v { height: 100%; width: 2px; left: 9px; }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            z-index: 10;
        }

        h1 {
            font-size: 60px;
            color: #0ff;
            text-shadow: 0 0 20px #0ff;
            margin-bottom: 10px;
        }

        p { font-size: 20px; color: #aaa; margin-top: 0; }
        
        .btn {
            margin-top: 30px;
            padding: 15px 40px;
            background: transparent;
            border: 2px solid #f0f;
            color: #f0f;
            font-size: 24px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            transition: 0.3s;
            box-shadow: 0 0 15px #f0f;
        }

        .btn:hover {
            background: #f0f;
            color: #000;
        }

        #game-over-screen { display: none; }
        
        #health-bar-container {
            width: 300px;
            height: 20px;
            background: #333;
            border: 2px solid #555;
        }
        
        #health-bar {
            width: 100%;
            height: 100%;
            background: #0f0;
            transition: width 0.2s, background-color 0.2s;
            box-shadow: 0 0 10px #0f0;
        }

        .hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
    </style>
    <!-- Import Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="hud-top">
            <div>第 <span id="level-display">1</span> 层</div>
            <div id="health-bar-container">
                <div id="health-bar"></div>
            </div>
            <div>分数: <span id="score-display">0</span></div>
        </div>
        <div id="hud-bottom">敌人剩余: <span id="enemies-display">0</span></div>
    </div>

    <div id="crosshair">
        <div class="cross-line cross-h"></div>
        <div class="cross-line cross-v"></div>
    </div>

    <div class="hit-flash" id="hit-flash"></div>

    <div id="start-screen">
        <h1>霓虹深渊</h1>
        <p>FPS ROGUELIKE</p>
        <p>WASD移动 / 鼠标瞄准 / 左键射击</p>
        <button class="btn" id="start-btn">进入深渊</button>
    </div>

    <div id="game-over-screen">
        <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">你的意识消散了</h1>
        <p>存活层数: <span id="final-level">1</span></p>
        <p>最终得分: <span id="final-score">0</span></p>
        <button class="btn" id="restart-btn">重构意识</button>
    </div>

    <script>
        // --- Audio System (Procedural) ---
        const AudioSys = {
            ctx: null,
            init: function() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playShoot: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(800, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            },
            playExplosion: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.3);
            },
            playHit: function() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }
        };

        // --- Game Constants ---
        const WALL_SIZE = 10;
        const MAP_SIZE = 20; // 20x20 grid
        const PLAYER_SPEED = 80.0; // Adjusted speed
        const PLAYER_HEIGHT = 4;
        const BULLET_SPEED = 100;
        
        // --- Global Variables ---
        let camera, scene, renderer;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let raycaster = new THREE.Raycaster();
        
        // Game State
        let isGameActive = false;
        let level = 1;
        let score = 0;
        let playerHealth = 100;
        
        // Entities
        let walls = [];
        let bullets = [];
        let enemies = [];
        let particles = [];
        let mapData = []; // 0 empty, 1 wall

        // Elements
        const scoreEl = document.getElementById('score-display');
        const levelEl = document.getElementById('level-display');
        const enemiesEl = document.getElementById('enemies-display');
        const healthBar = document.getElementById('health-bar');
        const hitFlash = document.getElementById('hit-flash');
        
        // Setup
        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.015);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // IMPORTANT: Set rotation order to YXZ to prevent gimbal lock (camera rolling when looking up/down)
            // This ensures Y rotation is always global (left/right) and X rotation is local (up/down)
            camera.rotation.order = 'YXZ';

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040); // soft white light
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(0, 20, 10);
            scene.add(dirLight);

            // Floor
            const planeGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            const planeMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x111111, 
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            const floor = new THREE.Mesh(planeGeometry, planeMaterial);
            floor.rotation.x = - Math.PI / 2;
            scene.add(floor);

            // Controls Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            window.addEventListener('resize', onWindowResize);
            
            // UI Buttons
            document.getElementById('start-btn').addEventListener('click', () => {
                AudioSys.init();
                startGame();
            });
            document.getElementById('restart-btn').addEventListener('click', () => {
                startGame();
            });

            // Pointer Lock
            renderer.domElement.addEventListener('click', () => {
                if(isGameActive) document.body.requestPointerLock();
            });
            
            // --- MOUSE LOOK LOGIC ---
            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === document.body) {
                    const sensitivity = 0.002;
                    
                    // Mouse Left/Right controls global Y rotation
                    camera.rotation.y -= event.movementX * sensitivity;
                    
                    // Mouse Up/Down controls local X rotation
                    // Note: In Three.js, negative rotation X is looking UP
                    // Mouse moving DOWN (positive Y on screen) should make us look DOWN (positive rotation X)
                    // So we add movementY.
                    camera.rotation.x -= event.movementY * sensitivity;
                    
                    // Clamp looking up/down to approx 90 degrees
                    const limit = Math.PI / 2 - 0.1;
                    camera.rotation.x = Math.max(-limit, Math.min(limit, camera.rotation.x));
                }
            });
        }

        function startGame() {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Reset State
            level = 1;
            score = 0;
            playerHealth = 100;
            velocity.set(0,0,0);
            
            updateHUD();
            
            // Start Level
            startLevel();
            
            isGameActive = true;
            document.body.requestPointerLock();
            prevTime = performance.now();
        }

        function startLevel() {
            // Clear previous level
            walls.forEach(w => scene.remove(w));
            walls = [];
            enemies.forEach(e => scene.remove(e.mesh));
            enemies = [];
            bullets.forEach(b => scene.remove(b.mesh));
            bullets = [];
            
            generateMap();
            spawnEnemies();
            
            // Reset Player Pos
            let found = false;
            while(!found) {
                let x = Math.floor(Math.random() * MAP_SIZE);
                let z = Math.floor(Math.random() * MAP_SIZE);
                if(mapData[x + z * MAP_SIZE] === 0) {
                    camera.position.set(x * WALL_SIZE, PLAYER_HEIGHT, z * WALL_SIZE);
                    // Reset view angle
                    camera.rotation.set(0, 0, 0);
                    found = true;
                }
            }
            
            levelEl.innerText = level;
        }

        function generateMap() {
            mapData = new Array(MAP_SIZE * MAP_SIZE).fill(1); // Start all walls
            
            // Random Walk Dungeon Generation
            let x = Math.floor(MAP_SIZE / 2);
            let y = Math.floor(MAP_SIZE / 2);
            let steps = Math.floor(MAP_SIZE * MAP_SIZE * 0.6); // 60% open space
            
            for(let i=0; i<steps; i++) {
                mapData[x + y * MAP_SIZE] = 0; // Carve floor
                
                const dir = Math.floor(Math.random() * 4);
                if(dir === 0) x++;
                else if(dir === 1) x--;
                else if(dir === 2) y++;
                else if(dir === 3) y--;
                
                // Clamp
                if(x < 1) x = 1;
                if(x > MAP_SIZE - 2) x = MAP_SIZE - 2;
                if(y < 1) y = 1;
                if(y > MAP_SIZE - 2) y = MAP_SIZE - 2;
            }

            // Build Meshes
            const boxGeo = new THREE.BoxGeometry(WALL_SIZE, WALL_SIZE * 1.5, WALL_SIZE);
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 });
            const edgesMat = new THREE.LineBasicMaterial({ color: 0xffffff });

            for(let ix=0; ix<MAP_SIZE; ix++) {
                for(let iy=0; iy<MAP_SIZE; iy++) {
                    if(mapData[ix + iy * MAP_SIZE] === 1) {
                        const wall = new THREE.Mesh(boxGeo, wallMat);
                        wall.position.set(ix * WALL_SIZE, WALL_SIZE * 0.75, iy * WALL_SIZE);
                        
                        // Add neon edge
                        const edges = new THREE.EdgesGeometry(boxGeo);
                        const line = new THREE.LineSegments(edges, edgesMat);
                        wall.add(line);

                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
        }

        function spawnEnemies() {
            let enemyCount = 3 + Math.floor(level * 1.5);
            const geo = new THREE.SphereGeometry(2, 16, 16);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xff0055, 
                emissive: 0xaa0022, 
                emissiveIntensity: 0.5,
                roughness: 0.2 
            });

            while(enemies.length < enemyCount) {
                let ex = Math.floor(Math.random() * MAP_SIZE);
                let ez = Math.floor(Math.random() * MAP_SIZE);
                
                if(mapData[ex + ez * MAP_SIZE] === 0) {
                    let worldX = ex * WALL_SIZE;
                    let worldZ = ez * WALL_SIZE;
                    let dist = Math.sqrt(Math.pow(worldX - camera.position.x, 2) + Math.pow(worldZ - camera.position.z, 2));
                    
                    if(dist > 30) {
                        const enemyMesh = new THREE.Mesh(geo, mat);
                        enemyMesh.position.set(worldX, 2, worldZ);
                        scene.add(enemyMesh);
                        
                        enemies.push({
                            mesh: enemyMesh,
                            health: 2 + Math.floor(level / 2),
                            speed: 10 + (level * 1.5)
                        });
                    }
                }
            }
            updateHUD();
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function onMouseDown(event) {
            if(!isGameActive) return;
            if(document.pointerLockElement !== document.body) return;
            
            AudioSys.playShoot();
            
            const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            bullet.position.copy(camera.position);
            bullet.position.y -= 0.5; 
            
            // Get shoot direction (This CAN be up/down)
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            
            bullets.push({
                mesh: bullet,
                velocity: dir.multiplyScalar(BULLET_SPEED),
                life: 2.0
            });
            scene.add(bullet);
            
            // Recoil
            camera.rotation.x += 0.02;
        }

        function checkWallCollision(position) {
            const gridX = Math.round(position.x / WALL_SIZE);
            const gridZ = Math.round(position.z / WALL_SIZE);
            
            if(gridX < 0 || gridX >= MAP_SIZE || gridZ < 0 || gridZ >= MAP_SIZE) return true;
            return mapData[gridX + gridZ * MAP_SIZE] === 1;
        }

        function takeDamage(amount) {
            playerHealth -= amount;
            AudioSys.playHit();
            
            hitFlash.style.opacity = 0.5;
            setTimeout(() => hitFlash.style.opacity = 0, 100);
            
            updateHUD();
            
            if(playerHealth <= 0) {
                gameOver();
            }
        }

        function gameOver() {
            isGameActive = false;
            document.exitPointerLock();
            document.getElementById('game-over-screen').style.display = 'flex';
            document.getElementById('final-level').innerText = level;
            document.getElementById('final-score').innerText = score;
        }

        function updateHUD() {
            scoreEl.innerText = score;
            enemiesEl.innerText = enemies.length;
            
            let hpPercent = Math.max(0, playerHealth);
            healthBar.style.width = hpPercent + '%';
            if(hpPercent > 60) healthBar.style.backgroundColor = '#0f0';
            else if(hpPercent > 30) healthBar.style.backgroundColor = '#ff0';
            else healthBar.style.backgroundColor = '#f00';
        }

        function createParticles(pos, color, count) {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10,
                    (Math.random() - 0.5) * 10
                );
                
                particles.push({
                    mesh: mesh,
                    velocity: vel,
                    life: 1.0
                });
                scene.add(mesh);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (!isGameActive) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            // --- Player Movement Physics (XZ Plane Only) ---
            // We calculate directions manually based on YAW only to stay flat on ground
            
            // Friction
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            
            // Calculate horizontal forward/right vectors based on Camera Yaw
            // Yaw is rotation.y
            const yaw = camera.rotation.y;
            
            // Standard Trig for Forward (0,0,-1 rotated by yaw)
            const forwardX = -Math.sin(yaw);
            const forwardZ = -Math.cos(yaw);
            
            // Standard Trig for Right (1,0,0 rotated by yaw)
            const rightX = Math.cos(yaw);
            const rightZ = -Math.sin(yaw);
            
            // Input Vector
            let moveX = 0;
            let moveZ = 0;
            
            if(moveForward) { moveX += forwardX; moveZ += forwardZ; }
            if(moveBackward) { moveX -= forwardX; moveZ -= forwardZ; }
            if(moveRight) { moveX += rightX; moveZ += rightZ; }
            if(moveLeft) { moveX -= rightX; moveZ -= rightZ; }
            
            // Normalize diagonal movement
            const len = Math.sqrt(moveX*moveX + moveZ*moveZ);
            if(len > 0) {
                moveX /= len;
                moveZ /= len;
            }

            // Apply Speed
            velocity.x += moveX * PLAYER_SPEED * delta;
            velocity.z += moveZ * PLAYER_SPEED * delta;

            const oldPos = camera.position.clone();
            
            // Apply X Movement & Collision
            camera.position.x += velocity.x * delta;
            if(checkWallCollision(camera.position)) {
               camera.position.x = oldPos.x; 
            }
            
            const midPos = camera.position.clone();

            // Apply Z Movement & Collision
            camera.position.z += velocity.z * delta;
            if(checkWallCollision(camera.position)) {
               camera.position.z = midPos.z; 
            }
            
            // Force Height (no flying)
            camera.position.y = PLAYER_HEIGHT;

            // --- Bullets ---
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                const moveVec = b.velocity.clone().multiplyScalar(delta);
                b.mesh.position.add(moveVec);
                b.life -= delta;

                if(checkWallCollision(b.mesh.position) || b.life <= 0) {
                    scene.remove(b.mesh);
                    bullets.splice(i, 1);
                    continue;
                }

                for(let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if(b.mesh.position.distanceTo(e.mesh.position) < 2.5) {
                        e.health--;
                        createParticles(e.mesh.position, 0xff0055, 3);
                        scene.remove(b.mesh);
                        bullets.splice(i, 1);
                        
                        e.mesh.material.emissive.setHex(0xffffff);
                        setTimeout(() => { if(e.mesh) e.mesh.material.emissive.setHex(0xaa0022); }, 50);

                        if(e.health <= 0) {
                            AudioSys.playExplosion();
                            createParticles(e.mesh.position, 0xff0055, 10);
                            scene.remove(e.mesh);
                            enemies.splice(j, 1);
                            score += 100 * level;
                            updateHUD();
                            
                            if(enemies.length === 0) {
                                setTimeout(() => {
                                    level++;
                                    startLevel();
                                }, 1000);
                            }
                        }
                        break;
                    }
                }
            }

            // --- Enemies ---
            enemies.forEach(e => {
                const toPlayer = new THREE.Vector3().subVectors(camera.position, e.mesh.position);
                toPlayer.y = 0;
                const dist = toPlayer.length();
                toPlayer.normalize();
                
                const moveStep = toPlayer.multiplyScalar(e.speed * delta);
                const potentialPos = e.mesh.position.clone().add(moveStep);
                
                if(!checkWallCollision(potentialPos)) {
                     e.mesh.position.add(moveStep);
                }

                if(dist < 2.5) {
                    takeDamage(10 * delta * 3); // Continuous damage scaling
                    // Push player slightly? No, disorienting.
                }
                
                const scale = 1 + Math.sin(time * 0.01) * 0.1;
                e.mesh.scale.set(scale, scale, scale);
            });

            // --- Particles ---
            for(let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.velocity.clone().multiplyScalar(delta));
                p.life -= delta;
                p.mesh.scale.multiplyScalar(0.9); 
                if(p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>